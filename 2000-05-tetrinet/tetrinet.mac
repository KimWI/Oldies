; -----------------------------------------------------------------------
;
;    MSX Tetrinet 1.1
;    Copyright (C) 2000,2004 by Ricardo Bittencourt
;
;    Project started at 18/5/2000. Last modification was on 27/9/2004.
;    Contact the author through the addresses: 
;        
;        ricardo@700km.com.br
;        http://www.mundobizarro.tk
;
;    This code is open source under the Apache license.
;
; -----------------------------------------------------------------------        
;
; Credits:
;
;       Programming
;               Ricardo Bittencourt (main programmer)
;       Music
;               Alex Mitsio Sato
; 
;       No penguins were harmed during the making of this program.
;
; -----------------------------------------------------------------------        

	ASEG

INIT32  EQU     0006Fh
ERAFNK  EQU     000CCh
DISSCR  EQU     00041h
ENASCR  EQU     00044h
CHGET   EQU     0009Fh
LDIRMV  EQU     0005Ch
LDIRVM  EQU     00059h
CHGCLR  EQU     00062h
BDRCLR  EQU     0F3EBh
FILVRM  EQU     00056h
HKEYI   EQU     0FD9Ah
HTIMI   EQU     0FD9Fh
JIFFY   EQU     0FC9Eh
SETWRT  EQU     00053h
VDPRD   EQU     00006h
VDPWR   EQU     00007h
IRQID   EQU     0002Bh
GICINI  EQU     00090h
SNSMAT  EQU     00141h
WRTPSG  EQU     00093h
GTSTCK  EQU     000D5h
GTTRIG  EQU     000D8h
WRTVRM  EQU     0004Dh
RDVRM   EQU     0004Ah
INIGRP  EQU	00072h
RG1SAV  EQU	0F3E0h
WRTVDP	EQU	00047h
BREAKX	EQU	000B7h
CHPUT   EQU 	000A2h

; -----------------------------------------------------------------------        

        .phase  0C000h-7

        ;header for .BIN file
        DB      0FEh
        DW      0C000h
        DW      ENDOFCODE-1
        DW      START

; -----------------------------------------------------------------------        

GAMESPEED       EQU     50

; -----------------------------------------------------------------------        

INITIAL         DEFL    0D000h

RESERVE         MACRO   LABEL_NAME,N

LABEL_NAME      EQU     INITIAL
_&LABEL_NAME    EQU     INITIAL-0D000h
INITIAL         DEFL    INITIAL+N

		ENDM

; -----------------------------------------------------------------------        

PLAYER_SIZE     DEFL    0

STRUCT          MACRO   LABEL_NAME,N

LABEL_NAME      EQU     PLAYER_SIZE
PLAYER_SIZE     DEFL    PLAYER_SIZE+N

		ENDM

; -----------------------------------------------------------------------        

STRUCT          NEXT_VRAM_ADDR,2
STRUCT          VRAM_START,2
STRUCT          FIELD,2
STRUCT          COUNTDOWN,1
STRUCT          ENEMY,2
STRUCT          JOY_NUMBER,1
STRUCT          JOY_TRIG1_NUMBER,1
STRUCT          LOG_ADDR,2
STRUCT          POWER_ADDR,2
STRUCT		WIN_XPOS,1
STRUCT          CURRENT_ADDR,2
STRUCT          CURRENT_MAX_ROTATION,1
STRUCT          CURRENT_ROTATION,1
STRUCT          NEXT_ADDR,2
STRUCT          NEXT_MAX_ROTATION,1
STRUCT          NEXT_ROTATION,1
STRUCT          CURRENT_POS,2
STRUCT          ROTATE_NOW,2
STRUCT          GO_RIGHT_NOW,2
STRUCT          GO_LEFT_NOW,2
STRUCT          GO_DOWN_NOW,2
STRUCT          GO_BOTTOM_NOW,2
STRUCT          ACTION_BUTTON,1
STRUCT          AUTOMATIC_DOWN,1
STRUCT          LAST_JOY,1
STRUCT          LAST_TRIG1,1
STRUCT          LOG_FIFO,4
STRUCT          POWER_FIFO,12

; -----------------------------------------------------------------------        

BGM_SIZE        DEFL    0

STRUCT_BGM      MACRO   LABEL_NAME,N

LABEL_NAME      EQU     BGM_SIZE
BGM_SIZE        DEFL    BGM_SIZE+N

		ENDM

; -----------------------------------------------------------------------        

STRUCT_BGM      BGM_POSITION,2
STRUCT_BGM      BGM_RESTART,2
STRUCT_BGM      BGM_WAIT,1

; -----------------------------------------------------------------------        

RESERVE         EVENT,1
RESERVE         GAMEOVER,2
RESERVE         DONT_ADD_POWER,1
RESERVE         SAVE_HOOK,5
RESERVE         OPENING_SCROLL,1
RESERVE		TICK,1
RESERVE         EMPTY_LINE,32
RESERVE         DUMMY_1,16
RESERVE         FIELD_1,16*23
RESERVE         DUMMY_2,16
RESERVE         FIELD_2,16*23
RESERVE         PLAYER1,PLAYER_SIZE
RESERVE         PLAYER2,PLAYER_SIZE
RESERVE         BGM1,BGM_SIZE
RESERVE         BGM2,BGM_SIZE
RESERVE         BLOCK_0,1*16
RESERVE         BLOCK_1,4*16
RESERVE         BLOCK_2,4*16
RESERVE         BLOCK_3,4*16
RESERVE         BLOCK_4,2*16
RESERVE         BLOCK_5,2*16
RESERVE         BLOCK_6,2*16

; -----------------------------------------------------------------------

CALLBACK_NUKE:
        INC     A
        RET     Z
LD_HL_0:
        LD      (HL),0
        RET

; -----------------------------------------------------------------------

CALLBACK_BASIC:
        INC     A
        CP      0A8h
        RET     C
        LD      (HL),080h
        RET

; -----------------------------------------------------------------------

CALLBACK_SWITCH:
        EX      AF,AF'
        LD      A,(DE)
        LD      (HL),A
        EX      AF,AF'
        LD      (DE),A
        INC     DE
        RET

; -----------------------------------------------------------------------

CALLBACK_TOP_FIELD:
        INC     A
        OR      E
        LD      E,A
        RET

; -----------------------------------------------------------------------

CALLBACK_ADD_POWER:
        CALL    IS_BLOCK
RET_COMBO:        
        RET     C
        INC     E
        RET

; -----------------------------------------------------------------------

CALLBACK_COUNT:
        INC     A
        CP      081h
        JR	RET_COMBO

; -----------------------------------------------------------------------

CALLBACK_ERASE_ONE:
        INC     A
        CP      081h
        RET     C
        INC     E
        LD      A,E
        CP      D
        RET     NZ
        JR	LD_HL_0

; -----------------------------------------------------------------------        

CALLBACK_ERASE_BOMB:
	CP	0ADh
	RET	NZ
	
	PUSH	HL
	POP	IY
	EXX
	LD	HL,ERASE_BOMB_TABLE
	LD	B,9
ERASE_BOMB_LOOP:
	LD	A,(HL)
	INC	HL
	CALL	ERASE_BLOCK
	DJNZ	ERASE_BOMB_LOOP
	EXX
	LD	IY,0D000h
	RET

; -----------------------------------------------------------------------

CALLBACK_COUNT_EMPTY:
        OR	A
        RET	NZ
        INC	E
        RET

; -----------------------------------------------------------------------        

ERASE_BLOCK:	
	LD	(ERASE_BLOCK_P1+2),A
	LD	(ERASE_BLOCK_P2+2),A
ERASE_BLOCK_P1:
	LD	A,(IY+16)
	INC	A
	CP	080h
	RET	C
ERASE_BLOCK_P2:
	LD	(IY+16),0
	EXX
	INC	D
	EXX
	RET

; -----------------------------------------------------------------------        

START:
	; stop the drive
	LD      B,120
STOP_DRIVE:
	PUSH    BC
	CALL    HTIMI
	POP     BC
	DJNZ    STOP_DRIVE
	
	LD	A,(VDPWR)
	LD	(OUT_VRAM+1),A
	
; ----------------------------------------------------------------------- 

RESTART:
	; opening screen
	XOR	A
	LD	(BDRCLR),A
	CALL	GICINI
	CALL	INIT32
	CALL	DISSCR
	CALL    ERAFNK

	; clear all vram
	XOR	A
	SBC	HL,HL
	LD	BC,16384
	CALL	FILVRM
	
	; draw logo box bounds
	LD	A,40
	LD	HL,1826h
	LD	C,19
	CALL	FILVRM

	INC	A
	LD	L,0A8h
	LD	C,15
	CALL	FILVRM
	
	LD	HL,OPENING_DATA
	CALL	UNCOMPRESS_VIDEO
	
	INC	HL
	; HL now points to OPENING_LOGO
	CALL	SMART_RLE
	
	; fill logo box sprites
	LD	HL,03880h
	PUSH	HL
	LD	C,64
FILL_LOGO_OUTER:
	LD	B,8
	CALL	RDVRM
FILL_LOGO_INNER:
	LD	E,A
	SLA	A
	OR	E
	DJNZ	FILL_LOGO_INNER
	SET	6,L
	CALL	WRTVRM
	RES	6,L	
	INC	HL
	DEC	C
	JR	NZ,FILL_LOGO_OUTER
	
	; mirror logo box sprites
	POP	HL
	LD	C,128
MIRROR_LOGO_OUTER:
	LD	B,8
	CALL	RDVRM
MIRROR_LOGO_INNER:
	RRCA
	RL	E
	DJNZ	MIRROR_LOGO_INNER
	INC	H
	LD	A,E
	CALL	WRTVRM
	DEC	H
	INC	HL
	DEC	C
	JR	NZ,MIRROR_LOGO_OUTER
	
	; set sprites 16x16 normal size
	LD	A,(RG1SAV)
	AND	0FCh
	OR	2
	LD	B,A
	LD	C,1
	CALL	WRTVDP
	
	CALL	ENASCR

; ----------------------------------------------------------------------- 

	LD	HL,SMALL_IRQ_HANDLER
	CALL	SET_IRQ
	EI
	CALL	WAIT_BUTTON

; ----------------------------------------------------------------------- 

	; init the SCREEN 1, with white border
	LD      A,0Fh
	LD      (BDRCLR),A
	CALL    INIT32
	CALL    DISSCR

; ----------------------------------------------------------------------- 

        ; clear pattern table
        XOR     A
        LD      BC,0800h
        LD      H,A
        LD      L,A
        CALL    FILVRM

; ----------------------------------------------------------------------- 

        ; clear data area
        LD      HL,0D000h
        LD      BC,INITIAL-0D000h
        CALL    FILL_ZEROS

        ; init player 1, combo
        LD      HL,INITP1_DATA
        LD      DE,PLAYER1
        LD      C,16
        LDIR

        ; init player 2, combo
        LD      DE,PLAYER2
        LD      C,16
        LDIR

        ; init the music, combo
        LD      DE,BGM1
        LD      C,10
        LDIR

; ----------------------------------------------------------------------- 

        ; init base pointer
        LD      IY,0D000h

	; init random seed
	LD      A,(JIFFY)
	OR      1
	LD      (JIFFY),A

; ----------------------------------------------------------------------- 

        ; init field data
        LD      HL,DUMMY_1   
        LD      DE,DUMMY_1+1 
        LD      BC,16*24*2-1 
        LD      (HL),C
        LDIR
        

; ----------------------------------------------------------------------- 

        ; init empty line
        LD      HL,0B0Bh 
        LD      (EMPTY_LINE+13),HL
        LD      (EMPTY_LINE+15),HL 
        LD      (IY+_EMPTY_LINE+31),L
        LD      H,8                   
        LD      (EMPTY_LINE+17),HL    
        LD      (IY+_EMPTY_LINE),H    

; ----------------------------------------------------------------------- 

	; draw the empty playfield
	LD      B,22
	LD      DE,01800h-32
BUILD_EMPTY_TABLE:
	LD      HL,EMPTY_LINE
	PUSH    BC
	EX      DE,HL
	LD      BC,32
	ADD     HL,BC
	EX      DE,HL
	PUSH    DE
	CALL    LDIRMV
	POP     DE
	POP     BC
	DJNZ    BUILD_EMPTY_TABLE

; ----------------------------------------------------------------------- 

        ; draw bottom of screen
        LD      HL,01800h+22*32
        LD      A,11
        LD      C,32*2
        CALL    FILVRM

; ----------------------------------------------------------------------- 

	; fill VRAM areas as specified by VIDEO_DATA
        ; remember b=0
	LD      HL,VIDEO_DATA
	CALL	UNCOMPRESS_VIDEO
	INC	HL

	; HL now points to POWERS_DATA
	CALL	SMART_RLE
	EX	DE,HL
	INC	HL

	; HL now points to WINLOSE_DATA
	CALL	SMART_RLE

; ----------------------------------------------------------------------- 

	; place the blocks in VRAM
	LD      B,5*8
	LD      DE,080h*8
BUILD_BLOCKS:
	PUSH    BC
	PUSH    DE
	LD      BC,8
	PUSH	BC
	LD      HL,BLOCK_SHAPE
	CALL    LDIRMV
	POP	BC
	POP     DE
	EX      DE,HL
	ADD     HL,BC
	EX      DE,HL
	POP     BC
	DJNZ    BUILD_BLOCKS

; ----------------------------------------------------------------------- 

        ; uncompress block data
        LD      DE,BLOCK_0
        LD      HL,COMPRESSED_BLOCKS
        LD      IX,COMPRESSED_INFO
        LD      C,080h
UNCOMPRESS_LOOP:
        LD      A,(IX)
        OR      A
        JR      Z,UNCOMPRESS_END
        JP      P,UNCOMPRESS_NOCHANGE
        LD      A,8
        ADD     A,C
        LD      C,A
UNCOMPRESS_NOCHANGE:
        LD      A,(IX)
        AND     07Fh
        LD      B,A
UNCOMPRESS_OUTER:
        PUSH    BC
        LD      B,8
UNCOMPRESS_INNER:
        RLC     (HL)
        SBC     A,A
        AND     C
        LD      (DE),A
        INC     DE
        DJNZ    UNCOMPRESS_INNER
        POP     BC
        INC     HL
        DJNZ    UNCOMPRESS_OUTER
        INC     IX
        JR      UNCOMPRESS_LOOP
UNCOMPRESS_END:

; ----------------------------------------------------------------------- 

	; set sprites 16x16 zoomed
	LD	A,(RG1SAV)
	OR	3
	LD	B,A
	LD	C,1
	CALL	WRTVDP

; ----------------------------------------------------------------------- 

        ; init both fields
        CALL    LOAD_PLAYER1
	CALL    INIT_FIELD
        CALL    DRAW_POWER_FIFO
        CALL    LOAD_PLAYER2
	CALL    INIT_FIELD
        CALL    DRAW_POWER_FIFO

	; enable screen
	CALL    ENASCR

; ----------------------------------------------------------------------- 

	; set the main irq
	LD	HL,IRQ_HANDLER
	CALL	SET_IRQ

	; init the PSG
	LD      A,11
	LD      E,64
	CALL    WRTPSG
        INC     A
	LD      E,31
	CALL    WRTPSG
	LD      A,7
	LD      E,188
	CALL    WRTPSG
        INC     A
	LD      E,16
	CALL    WRTPSG

        LD      (IY+_EVENT),1

; ----------------------------------------------------------------------- 

MAIN_LOOP:
        BIT     0,(IY+_GAMEOVER)
        JR      NZ,WIN_ANIMATION
	
        BIT     0,(IY+_EVENT)
	JR      Z,MAIN_LOOP

        CALL    FLUSH_SCREEN
        LD      (IY+_EVENT),0

        CALL    LOAD_PLAYER1
	CALL    CHECK_EVENT
        CALL    LOAD_PLAYER2
	CALL    CHECK_EVENT

	JR      MAIN_LOOP

; ----------------------------------------------------------------------- 

WIN_ANIMATION:
        CALL    FLUSH_SCREEN
        ; at this point B=0
	LD	C,-33
	LD	A,C
	
WIN_OUTER:
        BIT     0,(IY+_TICK)
	JR      Z,WIN_OUTER
	LD	(IY+_TICK),0

	LD	(WIN_ATTR+0),A
	LD	(WIN_ATTR+4),A
	LD	(WIN_ATTR+8),A
	LD	(WIN_ATTR+12),A
	SUB	C
	CP	72+33
	ADC	A,C
	PUSH	AF
	PUSH	BC
	LD	HL,WIN_ATTR
	LD	DE,01B00h
	LD	BC,16
	CALL	LDIRMV	
	POP	BC
	POP	AF
	DJNZ	WIN_OUTER
	
	CALL	WAIT_BUTTON
	JP	RESTART

; -----------------------------------------------------------------------

EXIT_GAME:
	; dummy pop return address for WAIT_BUTTON
	POP	BC

	; restore original IRQ handler
	CALL	RELEASE_IRQ
	
        ; stop the music and exit
	CALL    GICINI
        CALL    INIT32
        
        LD	HL,FINAL_MESSAGE
EXIT_GAME_MESSAGE:        
        LD	A,(HL)
        OR	A
        RET	Z
        PUSH	HL
        CALL	CHPUT
        POP	HL
        INC	HL
        JR	EXIT_GAME_MESSAGE
             

; -----------------------------------------------------------------------

LOAD_FIELD:
        LD      L,(IX+FIELD+0)
        LD      H,(IX+FIELD+1)
        RET

; -----------------------------------------------------------------------

WAIT_BUTTON:
	LD	H,0
WAIT_BUTTON_LOOP:
	CALL	BREAKX
	JR	C,EXIT_GAME
	LD	A,H
	INC	A
	AND	3
	LD	H,A
	CALL	GTTRIG
	OR	A
	JR	Z,WAIT_BUTTON_LOOP
	; fall through

; -----------------------------------------------------------------------        

RELEASE_IRQ:
	DI
	LD      HL,SAVE_HOOK
	LD      DE,HKEYI 
	LD      BC,5
	LDIR
	RET
	
; -----------------------------------------------------------------------

FLUSH_SCREEN:
        CALL    LOAD_PLAYER1
	CALL    DRAW_FIELD
        CALL    LOAD_PLAYER2
	; fall through

; -----------------------------------------------------------------------

DRAW_FIELD:
        LD      E,(IX+VRAM_START+0)
        LD      D,(IX+VRAM_START+1)
        CALL    LOAD_FIELD
        INC     HL
        INC     HL
        EXX     
        LD      B,22
DRAW_FIELD_LOOP:
        EXX
        EX      DE,HL
        CALL    SETWRT
        EX      DE,HL
        PUSH    HL
        LD      B,12
DRAW_FIELD_INNER:        
        LD      A,(VDPWR)
        LD      C,A
	OUTI
	JR	NZ,DRAW_FIELD_INNER
        POP     HL

        LD      C,16
        ADD     HL,BC
        EX      DE,HL
        ADD     HL,BC
        ADD     HL,BC
        EX      DE,HL
        EXX
        DJNZ    DRAW_FIELD_LOOP

        ; draw the power log

        LD      C,LOG_FIFO
        CALL    LOAD_OFFSET
        EX      DE,HL
        LD      L,(IX+LOG_ADDR)
        LD      H,(IX+LOG_ADDR+1)
        LD      B,4
POWER_LOG_OUTER:
        LD      A,(DE)
        RLCA
        RLCA
        ADD     A,24
        PUSH    BC
        LD      B,4
POWER_LOG_INNER:
        CALL    WRTVRM
        INC     HL
        INC     A
        DJNZ    POWER_LOG_INNER
        LD      C,32-4
        ADD     HL,BC
        POP     BC
        INC     DE
        DJNZ    POWER_LOG_OUTER
	RET

; -----------------------------------------------------------------------

CHECK_EVENT_SELF:
        LD      A,(IX+POWER_FIFO)
        OR      A
        RET     Z

CHECK_SELF_DOIT:
        ADD     A,3
        CALL    LOG_POWER
        SUB     3

        LD      B,A
        DJNZ    DOIT_CLEAR
        ; fall through

; -----------------------------------------------------------------------

        ; power: add line
        CALL    ADD_LINE
        JP      CHECK_EVENT_DELETE

; -----------------------------------------------------------------------

DOIT_CLEAR:
        DJNZ    DOIT_RANDOM

        ; power: clear line
        CALL    XOR_BLOCK
        CALL    CLEAR_LINE
        JP      CHECK_EVENT_XOR

; -----------------------------------------------------------------------

DOIT_RANDOM:
        DJNZ    DOIT_BASIC

        ; power: random remove blocks
        CALL    XOR_BLOCK
        LD      E,0
        LD      A,LOW(CALLBACK_COUNT)
        CALL    TEMPLATE

        LD      A,E
        LD	B,10
        CP      B
        JP      C,DOIT_NUKE_INSIDE

DOIT_RANDOM_OUTER:
        PUSH    BC
        LD      C,E
        CALL    RAND_GENERIC
        PUSH    DE
        LD      D,A
        LD      E,0
        LD      A,LOW(CALLBACK_ERASE_ONE)
        CALL    TEMPLATE
        POP     DE
        DEC     E
        POP     BC
        DJNZ    DOIT_RANDOM_OUTER

        JP      CHECK_EVENT_XOR

; -----------------------------------------------------------------------

DOIT_BASIC:
        DJNZ    DOIT_BOMB

        ; power: basic blocks
        CALL    XOR_BLOCK
        LD      A,LOW (CALLBACK_BASIC)
        JP      CHECK_EVENT_TEMPLATE

; -----------------------------------------------------------------------

DOIT_BOMB:
        DJNZ    DOIT_QUAKE

        ; power: bomb
        CALL    XOR_BLOCK
        LD      D,0
        LD      A,LOW(CALLBACK_ERASE_BOMB)
        CALL    TEMPLATE
        
	; at this point, D=number of blocks erased        
        
        LD      E,0
        LD	BC,64
        CALL	LOAD_FIELD
        ADD	HL,BC
        LD      BC,18*16
DOIT_BOMB_COUNT:
        LD      A,(HL)
        CALL    CALLBACK_COUNT_EMPTY
        INC     HL
        DEC     BC
        LD      A,B
        OR      C
        JR      NZ,DOIT_BOMB_COUNT
        
        ; at this point, D is preserved, 
        ; E=number of empty block below fourth line

	; if D>E then D=E
	LD	A,E
	CP	D
	JR	NC,DOIT_BOMB_START
	LD	D,E
DOIT_BOMB_START:
	LD	A,D
	OR	A
	JR	Z,CHECK_EVENT_XOR
	
DOIT_BOMB_OUTER:

	; points to end of field
	CALL	LOAD_FIELD
	LD	BC,22*16-1
	ADD	HL,BC
	
	; choose a random empty block
	LD	C,E
	CALL	RAND_GENERIC
	LD	C,A
	DEC	E
	
	; search backwards for the empty block
DOIT_BOMB_INNER:	
	LD	A,(HL)
	OR	A
	JR	NZ,DOIT_BOMB_NEXT
	DEC	C
	JR	NZ,DOIT_BOMB_NEXT
	LD	(HL),80h
	JR	DOIT_BOMB_PLACED
DOIT_BOMB_NEXT:
	DEC	HL
	JR	DOIT_BOMB_INNER
	
DOIT_BOMB_PLACED:
	DEC	D
	JR	NZ,DOIT_BOMB_OUTER

        JR      CHECK_EVENT_XOR

; -----------------------------------------------------------------------

CHECK_EVENT_OTHER:
        LD      A,(IX+POWER_FIFO)
        OR      A
        RET     Z

        LD      L,(IX+ENEMY+0)
        LD      H,(IX+ENEMY+1)
        PUSH    HL
        EX      (SP),IX

        CALL    CHECK_SELF_DOIT

        POP     IX
        JR      CHECK_EVENT_DELETE

; -----------------------------------------------------------------------

DOIT_QUAKE:
        DJNZ    DOIT_GRAVITY

        CALL    XOR_BLOCK
        CALL    LOAD_FIELD
        LD      B,22
DOIT_QUAKE_OUTER:
        PUSH    BC
        LD      C,3
        CALL    RAND_GENERIC
        DEC     A
        JR      Z,DOIT_QUAKE_RIGHT
        JR      C,DOIT_QUAKE_LEFT
        LD      BC,16
        ADD     HL,BC
DOIT_QUAKE_END:
        POP     BC
        DJNZ    DOIT_QUAKE_OUTER
        JR      CHECK_EVENT_XOR

DOIT_QUAKE_RIGHT:
        LD      BC,12
        ADD     HL,BC
        LD      D,H
        LD      E,L
        INC     DE
        LD      A,(DE)
        DEC     BC
        LDDR
        LD      (DE),A
        LD      C,15
        ADD     HL,BC
        JR      DOIT_QUAKE_END

DOIT_QUAKE_LEFT:
        INC     HL
        INC     HL
        LD      D,H
        LD      E,L
        LD      A,(HL)
        INC     HL
        LD      BC,11
        LDIR
        LD      (DE),A
        INC     HL
        INC     HL
        JR      DOIT_QUAKE_END

; ----------------------------------------------------------------------- 

CHECK_EVENT_TEMPLATE:
        CALL    TEMPLATE

CHECK_EVENT_XOR:
        CALL    XOR_BLOCK

CHECK_EVENT_DELETE:
        LD      C,POWER_FIFO
        CALL    LOAD_OFFSET
        LD      D,H
        LD      E,L
        INC     HL
        LD      C,11
        LDIR
        LD      (IX+POWER_FIFO+11),C
        ; fall through

; ----------------------------------------------------------------------- 

DRAW_POWER_FIFO:
        ; draw the power fifo
        LD      C,POWER_FIFO
        CALL    LOAD_OFFSET
        EX      DE,HL
        LD      L,(IX+POWER_ADDR+0)
        LD      H,(IX+POWER_ADDR+1)
        LD      B,12
DRAW_POWER_LOOP:
        LD      A,(DE)
        INC     DE
        ADD     A,0A8h
        CALL    WRTVRM
        INC     HL
        DJNZ    DRAW_POWER_LOOP
        RET

; -----------------------------------------------------------------------

DOIT_GRAVITY:
        DJNZ    DOIT_SWITCH

        ; power: gravity
        CALL    XOR_BLOCK
        CALL    LOAD_FIELD
        LD      BC,21*16
        LD      DE,16
        ADD     HL,BC

DOIT_GRAVITY_OUTER:
        PUSH    HL
        LD      A,(HL)
        LD      (HL),D
        OR      A
        JR      Z,DOIT_GRAVITY_SKIP

        PUSH    AF
DOIT_GRAVITY_INNER:
        ADD     HL,DE
        LD      A,(HL)
        OR      A
        JR      Z,DOIT_GRAVITY_INNER
        SBC     HL,DE
        POP     AF
        LD      (HL),A

DOIT_GRAVITY_SKIP:
        POP     HL
        DEC     HL
        DEC     BC
        LD      A,B
        OR      C
        JR      NZ,DOIT_GRAVITY_OUTER

        SET     0,(IY+_DONT_ADD_POWER)
        CALL    REMOVE_LINES
        RES     0,(IY+_DONT_ADD_POWER)


        JR      CHECK_EVENT_XOR

; -----------------------------------------------------------------------
        
DOIT_SWITCH:
        DJNZ    DOIT_NUKE

        ; power: switch fields
        PUSH    IX

        CALL    LOAD_PLAYER2
        CALL    XOR_BLOCK
        CALL    LOAD_PLAYER1
        CALL    XOR_BLOCK

        LD      DE,FIELD_2
        LD      A,LOW (CALLBACK_SWITCH)
        CALL    TEMPLATE

        CALL    LOAD_PLAYER1
        CALL    CHECK_TOP_FIELD
        CALL    LOAD_PLAYER2
        CALL    CHECK_TOP_FIELD

        POP     IX
        JP      CHECK_EVENT_DELETE

; -----------------------------------------------------------------------

DOIT_NUKE:
        ; power: nuke
        CALL    XOR_BLOCK
DOIT_NUKE_INSIDE:
        LD      A,LOW (CALLBACK_NUKE)
        JP      CHECK_EVENT_TEMPLATE

; ----------------------------------------------------------------------- 

CHECK_EVENT:
        ; perform a rotation in current block
        SRL     (IX+ROTATE_NOW)
        JR      NC,CHECK_EVENT_RIGHT

        SRL     (IX+ACTION_BUTTON)
        JP      C,CHECK_EVENT_OTHER

        LD      L,1
        CALL    ROTATE_CURPOS
        LD      L,-1
        CALL    C,ROTATE_CURPOS

        ; fall through

; ----------------------------------------------------------------------- 

CHECK_EVENT_RIGHT:
        ; move current block right
        SRL     (IX+GO_RIGHT_NOW)
        JR      NC,CHECK_EVENT_LEFT

        CALL    INC_CUR_POS
        CALL    C,DEC_CUR_POS

        ; fall through

; ----------------------------------------------------------------------- 

CHECK_EVENT_LEFT:
        ; move current block left
        SRL     (IX+GO_LEFT_NOW)
        JR      NC,CHECK_EVENT_DOWN

        CALL    DEC_CUR_POS
        CALL    C,INC_CUR_POS

        ; fall through

; ----------------------------------------------------------------------- 

CHECK_EVENT_DOWN:
        ; move current block down
        SRL     (IX+GO_DOWN_NOW)
        JR      NC,CHECK_EVENT_AUTOMATIC

        SRL     (IX+ACTION_BUTTON)
        JP      C,CHECK_EVENT_SELF

CHECK_EVENT_GO:
        CALL    INCREMENT_BLOCK
        CALL    C,DECREMENT_BLOCK

        ; fall through

; ----------------------------------------------------------------------- 

CHECK_EVENT_AUTOMATIC:
        SRL     (IX+AUTOMATIC_DOWN)
        JR      C,CHECK_EVENT_GO

; ----------------------------------------------------------------------- 

CHECK_EVENT_BOTTOM:
        ; move current block to bottom of screen
        SRL     (IX+GO_BOTTOM_NOW)
        RET     NC

        SRL     (IX+ACTION_BUTTON)
        JP      C,CHECK_EVENT_DELETE

CHECK_BOTTOM_LOOP:
        CALL    INCREMENT_BLOCK
        JR      NC,CHECK_BOTTOM_LOOP

        ; fall through

; -----------------------------------------------------------------------

DECREMENT_BLOCK:
        LD      HL,-16
        CALL    CHANGE_CURPOS
        ; fall through

; ----------------------------------------------------------------------- 

CHOOSE_NEW_BLOCK:
        CALL    CHOOSE_NEXT
        CALL    REMOVE_LINES
        JP      INIT_NEW_BLOCK

; ----------------------------------------------------------------------- 

ROTATE_CURPOS:
        CALL    XOR_BLOCK
	LD      A,(IX+CURRENT_ROTATION)
        ADD     A,L
	AND     (IX+CURRENT_MAX_ROTATION)
	LD      (IX+CURRENT_ROTATION),A
        JR      XOR_BLOCK

; -----------------------------------------------------------------------

INCREMENT_BLOCK:
        LD      HL,16
        JR      CHANGE_CURPOS

; -----------------------------------------------------------------------

INC_CUR_POS:
        LD      HL,1
        JR      CHANGE_CURPOS

DEC_CUR_POS:
        ; carry is always on when called
        SBC	HL,HL
        ; fall through

CHANGE_CURPOS:
        CALL    XOR_BLOCK
        LD      A,(IX+CURRENT_POS+0)
        ADD     A,L
        LD      (IX+CURRENT_POS+0),A
        LD      A,(IX+CURRENT_POS+1)
        ADC     A,H
        LD      (IX+CURRENT_POS+1),A
        ; fall through

; ----------------------------------------------------------------------- 

XOR_BLOCK:
        PUSH    HL
        XOR     A
        EX      AF,AF'

        CALL    INIT_XOR_BLOCK

XOR_BLOCK_OUTER:
	PUSH    BC
        LD      BC,4*256
XOR_BLOCK_INNER:
        LD      A,(DE)
        AND     (HL)
        OR      C
        LD      C,A
	LD      A,(DE)
        XOR     (HL)
        LD      (HL),A
        INC     DE
        INC     HL
        DJNZ    XOR_BLOCK_INNER

        EX      AF,AF'
        OR      C
        EX      AF,AF'

        LD      C,16-4
	ADD     HL,BC
	POP     BC
        DJNZ    XOR_BLOCK_OUTER

        CALL    SET_EVENT

        EX      AF,AF'
        RLCA
        POP     HL
	RET

; -----------------------------------------------------------------------

REMOVE_LINES:
        LD      BC,21*16
        PUSH    BC
        XOR     A
        EX      AF,AF'

REMOVE_LINES_OUTER:
        POP     BC
        PUSH    BC
        CALL    LOAD_FIELD
        ADD     HL,BC
        LD      B,16
        LD      A,080h
REMOVE_LINES_INNER:
        AND     (HL)
        INC     HL
        DJNZ    REMOVE_LINES_INNER
        OR      A
        JP      P,REMOVE_LINES_NEXT

        EX      AF,AF'
        INC     A
        EX      AF,AF'

        ; push the powers, if any
        BIT     0,(IY+_DONT_ADD_POWER)
        JR      NZ,REMOVE_LINES_NOPOWER

        PUSH    HL
        LD      BC,-14
        ADD     HL,BC
        LD      B,12
CHECK_POWER_OUTER:
        LD      A,(HL)
        SUB     0A8h
        JR      C,CHECK_POWER_SKIP

        EXX
        LD      C,POWER_FIFO+10
        CALL    LOAD_OFFSET
        LD      D,H
        LD      E,L
        INC     DE
        LD      C,11
        LDDR
        LD      (DE),A
        EXX
CHECK_POWER_SKIP:
        INC     HL
        DJNZ    CHECK_POWER_OUTER
        POP     HL

REMOVE_LINES_NOPOWER:
        ; remove the line
        DEC     HL
        LD      D,H
        LD      E,L
        LD      BC,-16
        EX      DE,HL
        ADD     HL,BC
        POP     BC
        PUSH    BC
        LDDR

        CALL    LOAD_FIELD
        INC     HL
        INC     HL
        LD      C,12
        CALL    FILL_ZEROS
        JR      REMOVE_LINES_OUTER

REMOVE_LINES_NEXT:
        POP     HL
        LD      BC,-16
        ADD     HL,BC
        LD      A,H
        OR      L
        JR      Z,POWER_CLASSIC
        PUSH    HL
        JR      REMOVE_LINES_OUTER                

; ----------------------------------------------------------------------- 

POWER_CLASSIC:
        BIT     0,(IY+_DONT_ADD_POWER)
        RET     NZ

        CALL    DRAW_POWER_FIFO

        ; only add lines is 2 or more were removed
        EX      AF,AF'
        CP      2
        JR      C,ADD_POWER

        ; swap pointer with enemy
        PUSH    AF
        LD      L,(IX+ENEMY+0)
        LD      H,(IX+ENEMY+1)
        PUSH    HL
        EX      (SP),IX

        ; if tetris, add 4 lines, else add lines-1
        DEC     A
        CALL    LOG_POWER
        ADD     A,-3
        ADC     A,3

        LD      B,A
POWER_CLASSIC_OUTER:
        PUSH    BC
        CALL    ADD_LINE
        POP     BC
        DJNZ    POWER_CLASSIC_OUTER

        POP     IX
        POP     AF
        ; fall through

; -----------------------------------------------------------------------

ADD_POWER:
        OR      A
        RET     Z

        ; count how many basic block there are on the field
        PUSH    AF
        LD      E,0
        LD      A,LOW (CALLBACK_ADD_POWER)
        CALL    TEMPLATE
        POP     AF
        LD      L,A

        ; compare L=number of lines and E=number of blocks
        ; L must be less or equal than E
        LD      A,E
        CP      L
        JR      NC,ADD_POWER_OK
        LD      L,E
ADD_POWER_OK:

        ; and also e must be greater than zero
        OR      A
        RET     Z

        LD      C,E
        CALL    RAND_GENERIC
        INC     A
        LD      B,A
        LD      C,L

ADD_POWER_OUTER:
        PUSH    BC
        CALL    LOAD_FIELD
ADD_POWER_INNER:
        LD      A,(HL)
        CALL    IS_BLOCK
        JR      C,ADD_POWER_SKIP

        INC     HL
        DJNZ    ADD_POWER_INNER
        DEC     HL

        ; choose a random power
        PUSH    HL
        LD      C,064h
        CALL    RAND_GENERIC
        ;;;
        ;LD	A,70 ;; force power O
        ;;;
        LD      B,0A9h-1
        LD      HL,POWER_DESCRIPTION-1
ADD_POWER_CHOOSE:
        INC     HL
        INC     B
        CP      (HL)
        JR      NC,ADD_POWER_CHOOSE
        POP     HL

        LD      (HL),B
        POP     BC
        DEC     B
        DEC     C
        RET     Z
        JR      ADD_POWER_OUTER
                
ADD_POWER_SKIP:
        INC     HL
        JR      ADD_POWER_INNER

; ----------------------------------------------------------------------- 

CHECK_TOP_FIELD:
        CALL    LOAD_FIELD
        LD      A,LOW(CALLBACK_TOP_FIELD)
        LD      C,6*16
        LD      E,B
        CALL    TEMPLATE_LOADBC
        BIT     7,E
        JR      Z,CHECK_TOP_FIELD_EXIT
        CALL    CLEAR_LINE
        JR      CHECK_TOP_FIELD

CHECK_TOP_FIELD_EXIT:
        CALL    XOR_BLOCK
        CALL    C,OR_BLOCK_EX
        RET

; ----------------------------------------------------------------------- 

CLEAR_LINE:
        CALL    LOAD_FIELD
        LD      BC,22*16
        PUSH    BC
        ADD     HL,BC
        LD      D,H
        LD      E,L
        LD      BC,-16
        ADD     HL,BC
        POP     BC
        LDDR
        EX      DE,HL
        INC     HL
        INC     HL
        LD      C,12
        ; fall through

; -----------------------------------------------------------------------

FILL_ZEROS:
        LD      (HL),0
        INC     HL
        DEC     BC
        LD      A,B
        OR      C
        JR      NZ,FILL_ZEROS
        RET

; -----------------------------------------------------------------------
; uncompress video data 
; enter HL= compressed data
; requires B=0

UNCOMPRESS_VIDEO:
        LD      E,(HL)
	INC     HL
        LD      D,(HL)
        LD      A,D
        INC     A
	RET	Z
	
        INC     HL
        LD      C,(HL)
        INC     HL

        PUSH    HL
        PUSH    BC
        CALL    LDIRMV
        POP     BC
        POP     HL
        ADD     HL,BC
	JR      UNCOMPRESS_VIDEO

; -----------------------------------------------------------------------

TEMPLATE:
        LD      BC,22*16
TEMPLATE_LOADBC:
        LD      (TEMPLATE_PATCH+1),A
        CALL    LOAD_FIELD
TEMPLATE_LOOP:
        LD      A,(HL)
TEMPLATE_PATCH:
        CALL    0C000h
        INC     HL
        DEC     BC
        LD      A,B
        OR      C
        JR      NZ,TEMPLATE_LOOP
        RET

; -----------------------------------------------------------------------
; IS_BLOCK: return carry is A is a block (destroys A)

IS_BLOCK:
        CP      080h
        RET     C
        ADD     A,-0A8h
        RET

; -----------------------------------------------------------------------

LOG_POWER:
        LD      C,LOG_FIFO
        CALL    LOAD_OFFSET
        LD      D,H
        LD      E,L
        INC     HL
        LD      BC,3
        LDIR
        LD      (DE),A
        RET

; -----------------------------------------------------------------------

ADD_LINE:
        ; erase block from screen (exits with b=0)
        CALL    XOR_BLOCK

        ; scroll entire field 1 line up
        CALL    LOAD_FIELD
        LD      D,H
        LD      E,L
        LD      C,16
        ADD     HL,BC
        LD      BC,21*16
        LDIR

        ; add random blocks in the last line
        EX      DE,HL
        INC     HL
        INC     HL
        LD      B,12
ADD_LINE_BLOCK:
        PUSH    BC
        LD	C,5
        CALL	RAND_GENERIC
        POP     BC
        RLCA
        RLCA
        RLCA

        OR      080h
        LD      (HL),A
        INC     HL
        DJNZ    ADD_LINE_BLOCK

        ; erase one block from last line
        LD	C,0Ch
        CALL	RAND_GENERIC
        ; (remember cf=1 at this point)
        LD      C,A
        LD      B,0
        SBC     HL,BC
        LD      (HL),0

        ; place the block in the field back again
        CALL    XOR_BLOCK
        RET     NC
OR_BLOCK_EX:        
	CALL	OR_BLOCK
        JP      CHOOSE_NEW_BLOCK

; ----------------------------------------------------------------------- 

OR_BLOCK:
        CALL    XOR_BLOCK
        ; start or_block
        CALL    INIT_XOR_BLOCK

OR_BLOCK_OUTER:
	PUSH    BC
        LD      B,4
OR_BLOCK_INNER:
        LD      A,(HL)
        OR      A
        JR      NZ,OR_BLOCK_SKIP
	LD      A,(DE)
        LD      (HL),A
OR_BLOCK_SKIP:
        INC     DE
        INC     HL
        DJNZ    OR_BLOCK_INNER

        LD      C,16-4
	ADD     HL,BC
        POP     BC
        DJNZ    OR_BLOCK_OUTER
        ; end or_block
	RET
	
; ----------------------------------------------------------------------- 

INIT_FIELD:
        ; init the "next" blocks
        CALL    CHOOSE_NEXT
        CALL    CHOOSE_NEXT

	; init the memory field
        LD      D,22
        CALL    LOAD_FIELD
        INC     HL
        INC     HL
INIT_FIELD_LOOP:
        LD      C,12
        CALL    FILL_ZEROS
        LD      C,4
        ADD     HL,BC

        DEC     D
        JR      NZ,INIT_FIELD_LOOP

        ; fall through

; ----------------------------------------------------------------------- 

INIT_NEW_BLOCK:
        ; reset the countdown
        LD      (IX+COUNTDOWN),GAMESPEED

	; init the current position
        CALL    LOAD_FIELD
        LD      BC,6
	ADD     HL,BC
	LD      (IX+CURRENT_POS+0),L
	LD      (IX+CURRENT_POS+1),H
        CALL    XOR_BLOCK
        RET     NC

        ; game over !
        SET     0,(IY+_GAMEOVER)
        CALL	OR_BLOCK
        LD	A,(IX+WIN_XPOS)
        LD	(WIN_ATTR+1),A
        INC	A
        LD	(WIN_ATTR+9),A
        ADD	A,31
        LD	(WIN_ATTR+5),A
        INC	A
        LD	(WIN_ATTR+13),A        
        RET

; ----------------------------------------------------------------------- 

INIT_XOR_BLOCK:
	; eval addr of block
	LD      L,(IX+CURRENT_ADDR+0)
	LD      H,(IX+CURRENT_ADDR+1)
	LD      A,(IX+CURRENT_ROTATION)
	CALL    EVAL_ROTATION

	LD      E,(IX+CURRENT_POS+0)
	LD      D,(IX+CURRENT_POS+1)
	LD      B,4
	EX      DE,HL
        RET

; ----------------------------------------------------------------------- 

EVAL_ROTATION:
	RRCA
	RRCA
	RRCA
	RRCA
	ADD     A,L
	LD      L,A
        RET     NC
        INC     H
        RET

; ----------------------------------------------------------------------- 

LOAD_OFFSET:
        LD      B,0
        PUSH    IX
        POP     HL
        ADD     HL,BC
        RET

; ----------------------------------------------------------------------- 

CHOOSE_NEXT:
	; copy NEXT information to CURRENT
        LD      C,CURRENT_ADDR
        CALL    LOAD_OFFSET
        LD      D,H
        LD      E,L
        LD      C,4
        ADD     HL,BC
        LDIR

	; select a random number (0-127)
	CALL    RAND
	AND	07Fh

	LD      HL,BLOCK_DESCRIPTION
CHOOSE_LOOP:
	CP      (HL)
	JR      C,CHOOSE_THIS
	INC     HL
	INC     HL
	INC     HL
        INC     HL
	JR      CHOOSE_LOOP

CHOOSE_THIS:
	INC     HL
        LD      C,(HL)
        LD      (IX+NEXT_MAX_ROTATION),C

        INC     HL
	LD      A,(HL)
	INC     HL
	LD      H,(HL)
	LD      L,A

	LD      (IX+NEXT_ADDR+0),L
	LD      (IX+NEXT_ADDR+1),H
	CALL    RAND
	AND	07Fh
        AND     C
	LD      (IX+NEXT_ROTATION),A
	CALL    EVAL_ROTATION

	LD      E,(IX+NEXT_VRAM_ADDR)
	LD      D,(IX+NEXT_VRAM_ADDR+1)

	EX      DE,HL
	LD      C,4
CHOOSE_DRAW_OUTER:
	LD      B,4
	CALL    SETWRT
CHOOSE_DRAW_INNER:
	LD      A,(DE)
	OR      1
	CALL	OUT_VRAM
	INC     DE
	DJNZ    CHOOSE_DRAW_INNER
        PUSH    BC
        LD      C,32
        ADD     HL,BC
        POP     BC
	DEC     C
	JR      NZ,CHOOSE_DRAW_OUTER

	RET

; ----------------------------------------------------------------------- 

IRQ_HANDLER:
;
	LD      A,(VDPRD)
	INC     A
	LD      C,A
	IN      A,(C)
	AND     A
	RET     P
;

	; play the music
	LD      IX,BGM1
        CALL    PLAY_MUSIC
	LD      IX,BGM2
        CALL    PLAY_MUSIC

        ; check second button
        LD      HL,BUTTON2_DATA_P1
        CALL    CHECK_BUTTON2
        INC     HL
        CALL    CHECK_BUTTON2        

        ; read keyboard
        LD      IX,KEYBOARD_DATA
        LD      IY,0D000h
        LD      (IY+_EVENT),0
        LD	(IY+_TICK),1
        LD      DE,4
KEYBOARD_LOOP:
        LD      L,(IX+0)
        LD      H,(IX+1)
        LD      A,H
        OR      L
        JR      Z,KEYBOARD_EXIT

        LD      A,(IX+2)
        CALL    SNSMAT
        LD      C,A
        XOR     (HL)
        AND     (HL)
        AND     (IX+3)
        CP      1
        SBC     A,A
        INC     A
        DEC     HL
        LD      (HL),A
        OR      (IY+_EVENT)
        LD      (IY+_EVENT),A
        INC     HL
        LD      (HL),C

        ADD     IX,DE
        JR      KEYBOARD_LOOP
KEYBOARD_EXIT:

        CALL    LOAD_PLAYER1
        CALL    PERIODIC_CHECK

        CALL    LOAD_PLAYER2
        ; fall through

; -----------------------------------------------------------------------

PERIODIC_CHECK:
        CALL    UPDATE_JOYSTICK
        CALL    PLAYER_COUNTDOWN
        
        ; fall through

; -----------------------------------------------------------------------

JOYSTICK_BUTTON:
        LD      A,(IX+JOY_TRIG1_NUMBER)
        CALL    GTTRIG
        CP      (IX+LAST_TRIG1)
        RET     Z

        LD      (IX+LAST_TRIG1),A
        AND     A
        RET     Z

        SET     0,(IX+GO_BOTTOM_NOW)

SET_EVENT:
        SET     0,(IY+_EVENT)
        RET

; -----------------------------------------------------------------------

CHECK_BUTTON2:
        LD      A,(HL)
        INC     HL
        CALL    SNSMAT
        AND     (HL)
        INC     HL
        ADD     A,255
        SBC     A,A
        INC     A
        LD      D,A

        LD      A,(HL)
        INC     HL
        CALL    GTTRIG
        AND     1
        OR      D
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      (DE),A
        RET

; -----------------------------------------------------------------------

UPDATE_JOYSTICK:
        LD      A,(IX+JOY_NUMBER)
        CALL    GTSTCK
        CP      (IX+LAST_JOY)
        RET     Z

        LD      (IX+LAST_JOY),A
        LD      HL,JOYSTICK_DATA
        LD      B,A

JOYSTICK_LOOP:
        LD      A,(HL)
        OR      A
        RET     Z

        CP      B
        JR      NZ,JOYSTICK_NEXT

        INC     HL
        LD      A,(HL)
        INC     HL
        LD      (JOYSTICK_PATCH+2),A
JOYSTICK_PATCH:
        SET     0,(IX+0)
        CALL    SET_EVENT
        JR      JOYSTICK_LOOP
JOYSTICK_NEXT:
        INC     HL
        INC     HL
        JR      JOYSTICK_LOOP

; -----------------------------------------------------------------------

PLAYER_COUNTDOWN:
        DEC     (IX+COUNTDOWN)
        RET     NZ

        LD      (IX+COUNTDOWN),GAMESPEED
        SET     0,(IX+AUTOMATIC_DOWN)
        JR      SET_EVENT

; -----------------------------------------------------------------------

RAND_GENERIC:
        PUSH    HL
        LD      A,C
        LD      L,A
        LD      B,8
RAND_GENERIC_LOOP:
        SRL     A
        OR      L
        LD      L,A
        DJNZ    RAND_GENERIC_LOOP
        LD      B,L
        POP     HL
        ; fall through

; -----------------------------------------------------------------------

RAND_RANGED:
        CALL    RAND
        AND     B
        CP      C
        RET     C
        JR      RAND_RANGED

; -----------------------------------------------------------------------
; choose a random number in the set [0,255] with uniform distribution

RAND:
	PUSH    HL
	LD      HL,(JIFFY)
	ADD     HL,HL
	SBC     A,A
	AND     083h
	XOR     L
	LD      L,A
	LD      (JIFFY),HL
	;AND     07Fh
	POP     HL
	RET

; -----------------------------------------------------------------------
; PLAY_MUSIC: play a music slice pointed by IX

PLAY_MUSIC:
        DEC     (IX+BGM_WAIT)
	RET     NZ

	LD      L,(IX+BGM_POSITION+0)
	LD      H,(IX+BGM_POSITION+1)

PLAY_MUSIC_LOOP:
	LD      A,(HL)
	CP      15*16-1
	JR      NC,PLAY_MUSIC_WAIT
	CP      14*16-1
	JR      NC,PLAY_MUSIC_RESET
	CP      13*16-1
	JR      NC,PLAY_MUSIC_ENVELOPE
	CP      9*16-1
	JR      NC,PLAY_MUSIC_VOLUME
	RRCA
	RRCA
	RRCA
	RRCA
	PUSH    AF
	INC     HL
	LD      E,(HL)
	CALL    WRTPSG
	DEC     HL
	LD      A,(HL)
	AND     0Fh
	LD      E,A
	POP     AF
	INC     A
	INC     HL
PLAY_MUSIC_SEND_PSG:
	INC     HL
	CALL    WRTPSG
	JR      PLAY_MUSIC_LOOP

PLAY_MUSIC_VOLUME:
	AND     0Fh
	LD      E,A
	LD      A,9
	JR      PLAY_MUSIC_SEND_PSG

PLAY_MUSIC_ENVELOPE:
	LD      E,0
	LD      A,13
	JR      PLAY_MUSIC_SEND_PSG

PLAY_MUSIC_RESET:
	LD      L,(IX+BGM_RESTART+0)
	LD      H,(IX+BGM_RESTART+1)
	JR      PLAY_MUSIC_LOOP

PLAY_MUSIC_WAIT:
	AND     0Fh
	INC     HL
	EX      AF,AF'
	LD      A,(IRQID)
	RLCA
	JR      C,PLAY_MUSIC_50HZ
PLAY_MUSIC_60HZ:        
	EX      AF,AF'
	RLCA
	LD      E,A
	RLCA
	ADD     A,E
	JR      PLAY_MUSIC_EXIT
PLAY_MUSIC_50HZ:
	EX      AF,AF'
	LD      E,A
	RLCA
	RLCA
	ADD     A,E
PLAY_MUSIC_EXIT:
	LD      (IX+BGM_POSITION+0),L
	LD      (IX+BGM_POSITION+1),H
	LD      (IX+BGM_WAIT),A
	RET

; -----------------------------------------------------------------------        
; set the interrupt handler, enter HL=irq address

SET_IRQ:
	; save the old interrupt handler
	DI
	EXX
	LD      HL,HKEYI 
	LD      DE,SAVE_HOOK
	LD      BC,5
	LDIR
	EXX

	; install the new interrupt handler
	LD	A,0C3h
	LD	(HKEYI),A
	LD	(HKEYI+1),HL
	LD	A,0C9h
	LD	(HKEYI+3),A
	RET

; -----------------------------------------------------------------------        

OUT_VRAM:
	OUT	(0),A
	RET

; -----------------------------------------------------------------------        

SMART_RLE:
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	EX	DE,HL
	
SMART_RLE_LOOP:
	LD	A,(DE)
	LD	C,A
	INC	DE
	LD	A,(DE)
	AND	15
	RET	Z
	LD	B,A
	CALL	SMART_RLE_PUT
	LD	A,(DE)
	RLCA
	RLCA
	RLCA
	RLCA
	AND	15
	RET	Z
	LD	B,A
	INC	DE
	LD	A,(DE)
	INC	DE
	LD	C,A
	CALL	SMART_RLE_PUT
	JR	SMART_RLE_LOOP
	
SMART_RLE_PUT:
	LD	A,C
	CALL	WRTVRM
	INC	HL
	DJNZ	SMART_RLE_PUT

	; fall through

; -----------------------------------------------------------------------

LOAD_PLAYER2:
        LD      IX,PLAYER2
        RET

; -----------------------------------------------------------------------        
; must be the last routine in the game

SMALL_IRQ_HANDLER:
;
	LD      A,(VDPRD)
	INC     A
	LD      C,A
	IN      A,(C)
	AND     A
	RET     P
;
	LD	A,(OPENING_SCROLL)
	DEC	A
	LD	(OPENING_SCROLL),A
	RRCA
	RRCA
	AND	7
	LD	D,A
	LD	E,A
	
	SBC	HL,HL
	CALL	SETWRT
	
	LD	IX,GRID_PATTERN
	
	LD	B,8
OPENING_VERTICAL:
	LD	(IX+OPENING_PATCH+2-GRID_PATTERN),D
	LD	L,E
OPENING_PATCH:	
	LD	A,(IX+0)
OPENING_HORIZONTAL:
	RRCA
	DEC	L
	JR	NZ,OPENING_HORIZONTAL
	CALL	OUT_VRAM

	INC	D
	RES	3,D

	DJNZ	OPENING_VERTICAL

	; fall through
	
; -----------------------------------------------------------------------        

LOAD_PLAYER1:
        LD      IX,PLAYER1
        RET

; -----------------------------------------------------------------------        
; DATA AREA

VIDEO_DATA:
	; NULL_SHAPE
	DW      0
        DB      8 

GRID_PATTERN:
        DB      11111111b
        DB      00000001b
        DB      00000001b
        DB      00000001b
        DB      00000001b
        DB      00000001b
        DB      00000001b
        DB      00000001b

	; BORDER_SHAPE
	DW      8*8
        DB      2*8-7

	DB      00000001b
	DB      00000001b
	DB      00000001b
	DB      00000001b
	DB      00000001b
	DB      00000001b
	DB      00000001b
	DB      00000001b

	DB      00000001b

        DW      10*8
        DB      1

	DB      11111111b

        DW      13*8
        DB      2*8

	DB      00010000b
	DB      00110000b
	DB      01111110b
	DB      01111110b
	DB      00110000b
	DB      00010000b
	DB      00000000b
	DB      00000000b

	DB      00010001b
	DB      00011001b
	DB      11111101b
	DB      11111101b
	DB      00011001b
	DB      00010001b
	DB      00000001b
	DB      00000001b

	; NEXT_DATA
	DW      16*8
        DB      4*8-2

	DB      063h,073h,07Bh,06Fh,067h,063h,000h,000h
	DB      07Eh,060h,078h,060h,060h,07Eh,000h,000h
	DB      0C6h,06Ch,038h,038h,06Ch,0C6h,000h,000h
        DB      0FCh,030h,030h,030h,030h,030h


         ; NEXT_MSG PLAYER 1
        DW      01800h+14+12*32 ;-1
	DB      5

        DB      16,17,18,19,14

	; NEXT_MSG PLAYER 2
        DW      01800h+13 ;+1
	DB      5

        DB      13,16,17,18,19
	
        ; POWER_DATA
        DW      0A8h*8
        DB      10*8


        DB      000h,07Eh,042h,042h,042h,042h,07Eh,000h ; empty
        DB      000h,03Ch,066h,066h,07Eh,066h,066h,000h ; add
        DB      000h,03Ch,066h,060h,060h,066h,03Ch,000h ; clear
        DB      000h,07Ch,066h,066h,07Ch,066h,066h,000h ; random
        DB      000h,07Ch,066h,07Ch,066h,066h,07Ch,000h ; basic
        DB      000h,03Ch,066h,066h,066h,066h,03Ch,000h ; bomb
        DB      000h,03Ch,066h,066h,066h,06Ch,03Eh,000h ; quake
        DB      000h,03Ch,066h,060h,06Eh,066h,03Ch,000h ; gravity
        DB      000h,03Eh,060h,07Ch,03Eh,006h,07Ch,000h ; switch
        DB      000h,066h,076h,076h,06Eh,06Eh,066h,000h ; nuke

	; SCREEN_END
	DW      01800h+22*32
        DB      13

        DB      9,10,10,10,10,10,10,10
        DB      10,10,10,10,10

        DW      01800h+22*32+16+2
        DB      13
        
        DB      9,10,10,10,10,10
        DB      10,10,10,10,10,10,10
        
	; COLOR_TABLE
	DW      02000h
        DB      10

	DB      051h            ; null_block
	DB      05Fh            ; border_block
	DB      01Fh            ; next_data
        DB      01Eh            ; log powers
        DB      01Eh            ; log powers
        DB      01Eh            ; log powers
        DB      01Eh            ; log powers
        DB      01Eh            ; log powers
        DB      01Eh            ; log powers
        DB      01Eh            ; log powers

        DW      02000h+16
        DB      7

	DB      0CAh            ; yellow block
	DB      06Dh            ; purple block
	DB      0C2h            ; green block
	DB      068h            ; red block
	DB      045h            ; blue block
        DB      04Fh            ; power block
        DB      04Fh            ; power block

	; END
	DW      0FFFFh

POWERS_DATA:
	DW	28*8
	INCLUDE	POWERZ.INC

WINLOSE_DATA:
	DW	03800h
	DB	224,34,96
	DB	112,34,49
	DB	57,34,27
	DB	31,34,14
	DB	7,34,6
	DB	14,34,140
	DB	156,34,216
	DB	248,34,112
	DB	119,31,119
	DB	6,34,134
	DB	198,18,230
	DB	102,17,118
	DB	62,34,30
	DB	14,18,6
	DB	192,34,224
	DB	96,34,113
	DB	51,34,59
	DB	31,18,30
	DB	28,33,6
	DB	14,34,12
	DB	28,34,152
	DB	184,50,240
	DB	112,17,102
	DB	103,150,102
	DB	14,35,142
	DB	206,18,238
	DB	110,17,126
	DB	62,34,30
	DB	14,2

WIN_ATTR:	
	DB	-33,16,0,9
	DB	-33,16+32,4,9
	DB	-33,16+1,8,9
	DB	-33,16+32+1,12,9


BLOCK_SHAPE:
	DB      00000000b
	DB      00000001b
	DB      00000000b
	DB      00000001b
	DB      00000000b
	DB      00000001b
	DB      00000001b
	DB      01010111b

; -----------------------------------------------------------------------        

OPENING_DATA:
	; sprite patterns for press start
	DW	03800h
	DB	8*8*2
	INCLUDE START.INC
	
	; logo box sprites
	DW	03800h+8*8*2
	DB	16 
	DB	1,1,2,2,4,4,8,8,16,16,32,32,64,64,128,128

	DW	03800h+8*8*2+32+8
	DB	8 
	DB	0F0h,16,32,32,64,64,128,128
	
	; sprite attributes
	DW	01B00h
	DB	16*4
	DB	160,112,0,15
	DB	160,112+16,4,15
	DB	160,112,8,14
	DB	160,112+16,12,14

	DB	8*4-1,23*8,16,3
	DB	8*4-1,23*8,24,12

	DB	8*2-1,24*8,16,3
	DB	8*2-1,24*8,24,12

	DB	8*0-1,25*8,20,3
	DB	8*0-1,25*8,28,12

	DB	8*4-1,7*8,16+32,3
	DB	8*4-1,7*8,24+32,12

	DB	8*2-1,6*8,16+32,3
	DB	8*2-1,6*8,24+32,12

	DB	8*0-1,5*8,20+32,3
	DB	8*0-1,5*8,28+32,12

	; block colors
	DW	2000h
	DB	6
	DB	041h,0BCh,0BCh,0BCh,0BCh,03Ch
	
	; logo box tiles
	DW	40*8
	DB	1	
	DB	255
	DW	40*8+2*8-1
	DB	1
	DB	255

	; logo name
	DW	01800h+8+32*2-1
	DB	17
  	DB	18,8, 9,10,11,12,13,14,15,16,14,15,10,11,14,17,18
  	
	DW	01800h+8+32*3-1
	DB	17
 	DB	18,18,19,20,21,22,23,24,25,26,24,19,20,21,24,18,18

	DW	01800h+8+32*4
	DB	15
 	DB	18,27,28,29,30,31,32,27,33,32,27,28,29,32,18

	; end data
	DW	0FFFFh
	
OPENING_LOGO:
	DW	8*8
	INCLUDE	LOGOZ.INC
		
; -----------------------------------------------------------------------        
; Power descriptions
;
; 0 = Add line          19  19
; 1 = Clear line        16  35
; 2 = Random Clear      14  49
; 3 = Basic             14  63
; 4 = Bomb              14  77
; 5 = Quake             11  88
; 6 = Gravity           6   94
; 7 = Switch            3   97
; 8 = Nuke              3  100


POWER_DESCRIPTION:
        DB      19
        DB      35
        DB      49
        DB      63
        DB      77
        DB      88
        DB      94
        DB      97
        DB      100

; -----------------------------------------------------------------------
; Block descriptions
;
; 0 = XX        (yellow)
;     XX
;
; 1 = XXX       (yellow)
;      X
;
; 2 = XXX       (purple)
;     X
;
; 3 = XXX       (green)
;       X
;
; 4 = XX        (red)
;      XX       
;
; 5 =  XX       (blue)
;     XX
;
; 6 = XXXX      (blue)
;

BLOCK_DESCRIPTION:
	DB      20
        DB      0
	DW      BLOCK_0
	DB      40
        DB      3
	DW      BLOCK_1
	DB      60
        DB      3
	DW      BLOCK_2
	DB      80
        DB      3
	DW      BLOCK_3
	DB      100
        DB      1
	DW      BLOCK_4
	DB      120
        DB      1
	DW      BLOCK_5
	DB      128
        DB      1
	DW      BLOCK_6

COMPRESSED_INFO:
        DB      2
        DB      8
        DB      8+080h
        DB      8+080h
        DB      4+080h
        DB      4+080h
        DB      4
        DB      0

COMPRESSED_BLOCKS:
        DB      01100110b
        DB      00000000b
        DB      01110010b
        DB      00000000b
        DB      00100110b
        DB      00100000b
        DB      00100111b
        DB      00000000b
        DB      01000110b
        DB      01000000b
        DB      01110100b
        DB      00000000b
        DB      01100010b
        DB      00100000b
        DB      00010111b
        DB      00000000b
        DB      01000100b
        DB      01100000b
        DB      01110001b
        DB      00000000b
        DB      00100010b
        DB      01100000b
        DB      01000111b
        DB      00000000b
        DB      01100100b
        DB      01000000b
        DB      01100011b
        DB      00000000b
        DB      00100110b
        DB      01000000b
        DB      00110110b
        DB      00000000b
        DB      01000110b
        DB      00100000b
        DB      00100010b
        DB      00100010b
        DB      11110000b
        DB      00000000b

; -----------------------------------------------------------------------        

BGM1_DATA:
	INCLUDE BGM1.INC

BGM2_DATA:
	INCLUDE BGM2.INC

; -----------------------------------------------------------------------        

INITP1_DATA:
        DW      14+13*32+01800h
        DW      31-12+01800h
        DW      FIELD_1
        DB      GAMESPEED
        DW      PLAYER2
        DB      1
        DB      1
        DW      14+18*32+01800h
        DW      19+23*32+01800h
        DB	16+8

INITP2_DATA:
        DW      14+1*32+01800h
        DW      1+01800h
        DW      FIELD_2
        DB      GAMESPEED
        DW      PLAYER1
        DB      2
        DB      2
        DW      14+6*32+01800h
        DW      1+23*32+01800h
        DB	256-16-64-8

; -----------------------------------------------------------------------        

INIT_BGM_DATA:
        DW      BGM1_DATA,BGM1_DATA
        DB      1
        DW      BGM2_DATA,BGM2_DATA
        DB      1               

; -----------------------------------------------------------------------        

ERASE_BOMB_TABLE:
	DB	-17,-16,-15,-1,0,1,15,16,17
	
; -----------------------------------------------------------------------        

KEYBOARD_DATA:
        ; up
        DW      PLAYER1+ROTATE_NOW+1
        DB      8,32
        ; right
        DW      PLAYER1+GO_RIGHT_NOW+1
        DB      8,128
        ; left
        DW      PLAYER1+GO_LEFT_NOW+1
        DB      8,16
        ; down
        DW      PLAYER1+GO_DOWN_NOW+1
        DB      8,64
        ; space
        DW      PLAYER1+GO_BOTTOM_NOW+1
        DB      8,1
        ; W
        DW      PLAYER2+ROTATE_NOW+1
        DB      5,16
        ; A
        DW      PLAYER2+GO_LEFT_NOW+1
        DB      2,64
        ; D
        DW      PLAYER2+GO_RIGHT_NOW+1
        DB      3,2
        ; S
        DW      PLAYER2+GO_DOWN_NOW+1
        DB      5,1
        ; caps
        DW      PLAYER2+GO_BOTTOM_NOW+1
        DB      6,8
        ; esc
        DW      GAMEOVER+1
        DB      7,16
        ; finish
        DW      0

; -----------------------------------------------------------------------        

JOYSTICK_DATA:
        ; up
        DB      1,ROTATE_NOW
        ; right
        DB      3,GO_RIGHT_NOW
        ; down
        DB      5,GO_DOWN_NOW
        ; left
        DB      7,GO_LEFT_NOW
        ; finish
        DB      0

BUTTON2_DATA_P1:
        DB      4,4,3
        DW      PLAYER1+ACTION_BUTTON

BUTTON2_DATA_P2:
        DB      7,8,4
        DW      PLAYER2+ACTION_BUTTON

FINAL_MESSAGE:
	DB	'Tetrinet 1.0',13,10,'by Ricardo Bittencourt',13,10,0

; -----------------------------------------------------------------------        

ENDOFCODE:

	;IF      ENDOFCODE GT 0CFFFh
	;.PRINTX . Larger than 4kb !!! .
	;ENDIF

	IF      INITIAL GT 0DE60h
	.PRINTX . Invading system area !!! .
	ENDIF

	END     START


